# name: test/sql/storage/optimistic_write/optimistic_write_concurrent_checkpoint_drop.test_slow
# description: Test that optimistically written blocks committed to the checkpoint WAL are not freed when the table is dropped after the checkpoint completes.
# group: [optimistic_write]

# If blocks are prematurely released the WAL replay of the concurrent INSERT will read garbage.

statement ok
PRAGMA disable_checkpoint_on_shutdown

statement ok
SET checkpoint_threshold = '1TB'

# Force row groups to flush to disk immediately, so that the WAL stores block pointers (WriteRowGroupData) instead of inline data (WriteInsert).
statement ok
SET write_buffer_row_group_count = 1

# Sleep long enough for the concurrent INSERT to COMMIT inside the checkpoint window.
statement ok
SET debug_checkpoint_sleep_ms = 500;

statement ok
ATTACH '__TEST_DIR__/concurrent_checkpoint_drop_opt.db' AS db

# Create table with a PRIMARY KEY. During WAL replay, ReplayRowGroupData must scan
# all blocks to rebuild the index, so corrupted blocks surface immediately.
statement ok
CREATE TABLE db.t (a BIGINT PRIMARY KEY, b VARCHAR, c VARCHAR, d VARCHAR)

# Insert an initial batch into the main WAL (before the checkpoint starts).
statement ok
INSERT INTO db.t
    SELECT i, repeat('x', 20), repeat('y', 30), repeat('z', 25)
    FROM range(0, 100000) t(i)

# Thread 0: triggers the checkpoint, then sleeps 500 ms after WALStartCheckpoint, giving Thread 1 time to commit into the checkpoint WAL.
# Thread 1: inserts a second batch: if it commits during the sleep it goes into the checkpoint WAL ("written to" branch).
concurrentloop threadid 0 2

onlyif threadid=0
statement ok
CHECKPOINT db

onlyif threadid=1
statement ok
INSERT INTO db.t
    SELECT i, repeat('a', 20), repeat('b', 30), repeat('c', 25)
    FROM range(100000, 350000) t(i)

endloop

# Drop table t. The blocks written by Thread 1's INSERT are still referenced by the new main WAL (the former checkpoint WAL).
statement ok
DROP TABLE db.t

# Insert into a new table â€” if the free list is incorrect then the allocator may
# hand out blocks that the WAL still points to, overwriting Thread 1's data.
statement ok
CREATE TABLE db.t2 (a DOUBLE, b DOUBLE, c DOUBLE, d DOUBLE)

statement ok
INSERT INTO db.t2
    SELECT i * 3.14159, i * 2.71828, i * 1.41421, i * 1.73205
    FROM range(0, 500000) t(i)

statement ok
DETACH db

# Reopen: WAL replay applies the checkpoint state, then replays the concurrent INSERT into t (reading from the physical blocks), the DROP TABLE, and the
# INSERT into t2. If the blocks were reused, ReplayRowGroupData will read garbage and the primary key rebuild will throw an internal exception or crash, so
# the ATTACH itself will fail.
statement ok
ATTACH '__TEST_DIR__/concurrent_checkpoint_drop_opt.db' AS db

query I
SELECT COUNT(*) FROM db.t2
----
500000

statement ok
DETACH db
